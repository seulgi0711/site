---
image: code-smell.png

title: "React.js HOC와 Render Prop으로 중복 로직 제거하기"
path: "/react-hoc-render-prop"
date: "2017-11-11"
coverImage: "../images/hello.jpg"
author: "nakta"
excerpt: '같은 코드가 여러군데에서 나타난다? 이 때부터 코드에서 냄새가 나기 시작한다고 한다.'
tags: ["react", "render prop"]
---

import { CodeWave } from 'gatsby-theme-waves';

같은 코드가 여러군데에서 나타난다? 이 때부터 코드에서 냄새가 나기 시작한다고 한다.
냄새가 나기 시작한 코드에서 중복코드가 발생한 부분에 수정이 필요할 경우 당연히 중복 수정을 해야한다.
이를 해결하기 위해 중복코드를 제거하고 코드를 재사용 하면 된다.
React로 개발하면서 중복 코드가 발생했을 때 컴포넌트를 활용해서 중복 로직을 제거하는 방법에 대해서 알아보자.

<CodeWave>

```jsx file=./01.jsx
```

아래 코드를 보면 memberId를 prop으로 받아서 멤버의 이름을 보여주는 간단한 컴포넌트다.

```jsx file=./02.jsx
```

그리고 다음 코드는 위와 마찬가지로 memberId를 prop으로 받아서 멤버의 닉네임을 보여주는 컴포넌트다.



위 두 컴포넌트에서 멤버의 이름과 닉네임을 가져오기 위해 membersStore에서 memberId를 이용해 멤버 정보를 가져오는 로직이 중복코드다.
이 멤버 정보를 가져오는 부분의 중복을 제거하는 작업을 살펴보자.

### HOC(Higher Order Component)
첫 번째로 <a href="https://reactjs.org/docs/higher-order-components.html" rel="noopener" target="_blank">HOC(Higher Order Component)</a>를 이용하는 방법이 있겠다. 
HOC를 간단하게 설명하면 컴포넌트를 감싸서 뭔가 작업을한 후 props를 통해 작업한 결과를 넘겨주는 컴포넌트라고 생각하면 된다.

HOC를 이용해서 어떻게 중복을 제거하는지 아래를 살펴보자.

아래를 보면 중복코드를 하나의 HOC 컴포넌트로 뽑아냈다.


```jsx file=./03.jsx
```

memberLoader HOC가 하는 일은 이전에 MemberName, MemberNickname 컴포넌트가 받았던 memberId를 prop으로 받아서 membersStore에 있는 멤버 정보를 가져다가 member라는 prop을 새로 만들어 전달하는 역할을 한다.

아래 memberLoader HOC를 이용한 MemberName과 MemberNickname이 있다.

</CodeWave>

```jsx
import PropTypes from 'prop-types';
import React, {PureComponent} from 'react';
import memberLoader from './memberLoader';

class MemberName extends PureComponent {
    static propTypes = {
        member: PropTypes.object.isRequired
    };

    render() {
        return <span>{this.props.member.name}</span>;
    }
}

export default memberLoader(MemberName);
```

```jsx
import PropTypes from 'prop-types';
import React, {PureComponent} from 'react';
import memberLoader from './memberLoader';

class MemberNickname extends PureComponent {
    static propTypes = {
        member: PropTypes.object.isRequired
    };

    render() {
        return <span>{this.props.member.nickname}</span>;
    }
}

export default memberLoader(MemberNickname);
```

MemberName, MemberNickname 컴포넌트를 export default 할때 memberLoader로 한 번 감싼 부분을 보자.
이렇게 사용하면 memberId를 memberLoader에서 처리해서 새로운 member prop을 받게 된다.

### Render Prop

두 번째로 Render Prop을 이용한 방법을 살펴보자. Render Prop을 간단하게 설명하면 렌더링 할 JSX를 function형태로 prop으로 넘기는 것을 맒한다.

```jsx
import PropTypes from 'prop-types';
import React, {PureComponent} from 'react';
import membersStore from './membersStore';

class MemberLoader extends PureComponent {
    static propTypes = {
        memberId: PropTypes.string.isRequired,
        render: PropTypes.func.isRequired
    };
    
    getMember = () => {
        membersStore.getById(this.props.memberId);
    };
    
    render() {
        return this.props.render(this.getMember());
    }
}

export default MemberLoader;
```

위 코드는 Render Prop을 이용해서 중복코드를 제거한 컴포넌트이다. 
HOC와 다른 점이 몇가지 있다.
1. function을 반환하는 게 아니라 class를 반환.
2. WrappedComponent를 받는게 아니라 render라는 prop이 필요.(render는 function이다.)

prop으로 받은 render 함수에 멤버정보를 파라미터로 넘기며 실행한다.

그럼 위 MemberLoader 컴포넌트를 어떻게 활용하는지 살펴보자.

```jsx
import PropTypes from 'prop-types';
import React, {PureComponent} from 'react';
import MemberLoader from './MemberLoader';

class MemberName extends PureComponent {
    static propTypes = {
        memberId: PropTypes.object.isRequired
    };

    render() {
        return (
            <MemberLoader 
                memberId={this.props.memberId}
                render={(member) => {
                    return <span>{member.name}</span>
                }}
            />
        );
    }
}

export default MemberName;
```

```jsx
import PropTypes from 'prop-types';
import React, {PureComponent} from 'react';
import MemberLoader from './MemberLoader';

class MemberNickname extends PureComponent {
    static propTypes = {
        memberId: PropTypes.object.isRequired
    };

    render() {
        return (
            <MemberLoader 
                memberId={this.props.memberId}
                render={(member) => {
                    return <span>{member.nickname}</span>
                }}
            />
        );
    }
}
export default MemberNickname;
```

MemberName과 MemberNickname에서 MemberLoader 컴포넌트를 사용하게 된다. 
prop으로 memberId를 넘겨서 MemberLoader 컴포넌트가 멤버 정보를 가져오도록 처리한다.
prop으로 render에 member를 받아서 각 각 이름과 닉네임을 반환해주는 함수를 넘겨준다. 이 render로 넘겨준 함수를 MemberLoader 컴포넌트가 멤버 정보화 함께 실행해준다.

개이적으로 처음에는 HOC 형태를 많이 썼으나 Render Prop을 알게 된 후로는 중복코드 제거에 Render Prop을 사용하고 있다.
Render Prop을 더 선호하는 이유에 몇가지가 있다.
1. HOC를 사용할 때 member prop이 어디서 오는지 알 수가 없다.

**MemberName을 사용할 때**
```jsx
<MemberName memberId={someMemberId}/>
```

위와 같은 형태로 **memberId만** prop으로 넘겨서 사용하게 된다.

**HOC**
 ```jsx
import PropTypes from 'prop-types';
import React, {PureComponent} from 'react';
import memberLoader from './memberLoader';

class MemberName extends PureComponent {
    static propTypes = {
        member: PropTypes.object.isRequired
    };

    render() {
        return <span>{this.props.member.name}</span>;
    }
}

export default memberLoader(MemberName);
```

실제 MemberName 컴포넌트를 사용 할 때는 memberId만 prop으로 넘겨줬는데 실제 사용하는 부분에서는 **member도 prop에 노출**되니 이 member가 어디서 온 prop인지 한 눈에 파악하기가 힘든점이 있다. 
반면에 Render Propr을 살펴보자.

**Render Prop**

```jsx
import PropTypes from 'prop-types';
import React, {PureComponent} from 'react';
import MemberLoader from './MemberLoader';

class MemberName extends PureComponent {
    static propTypes = {
        memberId: PropTypes.object.isRequired
    };

    render() {
        return (
            <MemberLoader 
                memberId={this.props.memberId}
                render={(member) => {
                    return <span>{member.name}</span>
                }}
            />
        );
    }
}

export default MemberName;
```

MemberName를 사용할 때 넘겨준 memberId를 그대로 MemberLoader로 넘겨주면서 함께 넘겨준 render 함수 내부에 member를 받아서 멤버의 이름 정보를 보여준다. 
개인적인 생각일 수있지만 HOC에 비해 훨씬 코드가 읽기 쉽다고 생각한다.

##### 2. HOC가 Render Prop방법에 비해 더 복잡해 보인다.

**HOC**
```jsx
import PropTypes from 'prop-types';
import React, {PureComponent} from 'react';
import membersStore from './membersStore';

export default function memberLoader(WrappedComponent) {
    class MemberLoader extends PureComponent {
        static propTypes = {
            memberId: PropTypes.string.isRequired
        };

        getMember = () =>
            membersStore.getById(this.props.memberId);
        
        render() {
            return <WrappedComponent {...this.props} member={this.getMember()}/>;
        }
    }
    return MemberLoader;
}
```

**Render Prop** 
```jsx
import PropTypes from 'prop-types';
import React, {PureComponent} from 'react';
import membersStore from './membersStore';

class MemberLoader extends PureComponent {
    static propTypes = {
        memberId: PropTypes.string.isRequired,
        render: PropTypes.func.isRequired
    };
    
    getMember = () => {
        membersStore.getById(this.props.memberId);
    };
    
    render() {
        return this.props.render(this.getMember());
    }
}

export default MemberLoader;
```

Render Prop이 React에서 사용하는 일반 컴포넌트 형태인것에 반해 HOC는 컴포넌트를 function으로 한번 더 감싼 행태이다. 
거기에 한 번 더 감싸줄 컴포넌트를 function의 파라미터로 받아 WrappedComponent를 render 메소드에서 렌더링 해준다.

이런 이유들로 Render Prop을 더 선호하는데 이건 개인취향이니 각자 알아서 골라쓰면 될것 같다.

**Render Prop에서 꼭 render라는 prop을 써야 할까??**

당연히 아니다 자신이 마음에 드는 prop 이름을 정의해서 사용하면 그만이다. 게다가 prop으로 넘기기도 귀찮다면 children을 이용해도 좋다.

```jsx
import PropTypes from 'prop-types';
import React, {PureComponent} from 'react';
import membersStore from './membersStore';

class MemberLoader extends PureComponent {
    static propTypes = {
        memberId: PropTypes.string.isRequired,
        children: PropTypes.func.isRequired
    };
    
    getMember = () => {
        membersStore.getById(this.props.memberId);
    };
    
    render() {
        return this.props.children(this.getMember());
    }
}

export default MemberLoader;
```


```jsx
import PropTypes from 'prop-types';
import React, {PureComponent} from 'react';

class MemberNickname extends PureComponent {
    static propTypes = {
        memberId: PropTypes.object.isRequired
    };

    render() {
        return (
            <MemberLoader memberId={this.props.memberId}>
                {(member) => {
                    return <span>{member.nickname}</span>
                }}
            </MemberLoader>
        );
    }
}

export default MemberNickname;
```

위 코드처럼 render prop 대신 MemberLoader의 children에 function을 넣어서 사용해도 결과는 같다.

[code-smell]: https://github.com/mojombo/jekyll
