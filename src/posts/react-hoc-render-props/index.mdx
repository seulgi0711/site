---
image: code-smell.png

title: "React.js HOC와 Render Prop으로 중복 로직 제거하기"
path: "/react-hoc-render-prop"
date: "2017-11-11"
coverImage: "../images/hello.jpg"
author: "nakta"
excerpt: '같은 코드가 여러군데에서 나타난다? 이 때부터 코드에서 냄새가 나기 시작한다고 한다.'
tags: ["react", "render prop"]
---

import { CodeWave } from 'gatsby-theme-waves';

같은 코드가 여러 곳에서 나타난다? 이 때부터 코드에서 냄새가 나기 시작한다고 합니다.
만약 중복 코드가 밟생한 부분의 로직이 수정돼야 한다면 어떻게 해야 할까요? 당연히 해당 로직이 사용된 모든곳을 찾아서 수정해줘야 합니다.
이런 문제를 해결하려면 중복코드를 제거해야되겠죠.
React로 개발하면서 중복 코드가 발생했을 때 컴포넌트를 활용해서 중복 로직을 제거하는 방법에 대해서 알아보도록 하겠습니다.

<CodeWave>

```jsx
import React, { PureComponent } from 'react';

class MemberName extends PureComponent {
  
}

export default MemberName;
```

## MemberName 컴포넌트

특정 멤버의 이름을 보여주기 위한 컴포넌트를 만들어보겠습니다.
`memberId`라는 값을 받아서 해당 아이디를 갖는 멤버의 이름을 보여주는 컴포넌트 입니다.

```jsx
import PropTypes from 'prop-types';
import React, { PureComponent } from 'react';

class MemberName extends PureComponent {
  static propTypes = {
    memberId: PropTypes.string.isRequired,
  };
  
}

export default MemberName;
```

`memberId`를 prop으로 받아야 하기 때문에 propTyeps에 memberId 타입을 지정해줍니다.
여기서는 memberId를 string으로 받습니다. memberId가 꼭 필요하기 때문에 isRequired를 붙였습니다.


```jsx
import PropTypes from 'prop-types';
import React, { PureComponent } from 'react';
import membersStore from './membersStore';

class MemberName extends PureComponent {
  static propTypes = {
    memberId: PropTypes.string.isRequired,
  };

  getMember = () => {
    return membersStore.getById(this.props.memberId);
  };
  
}

export default MemberName;
```

props으로 받은 memberId를 가지고 멤버정보를 받아와야합니다.
`membersStore`를 import 해서 `getById` 메소드를 이용해 멤버 정보를 가져오도록 합니다.


```jsx
import PropTypes from 'prop-types';
import React, { PureComponent } from 'react';
import membersStore from './membersStore';

class MemberName extends PureComponent {
  static propTypes = {
    memberId: PropTypes.string.isRequired,
  };

  getMember = () => {
    return membersStore.getById(this.props.memberId);
  };
  
  render() {
    return <div>{this.getMember().name}</div>;
  }
}

export default MemberName;
```

이제 `getMember` 메소드로 멤버 정보를 가져와 name을 렌더링 하도록 합니다.

</CodeWave>

<CodeWave>

```jsx
import React, { PureComponent } from 'react';

class MemberNickname extends PureComponent {
  
}

export default MemberNickname;
```

## MemberNickname 컴포넌트

이번에는 멤버의 별명을 보여주는 `MemberNickname` 컴포넌트를 만들어 보겠습니다.
`MemberName` 컴포넌트와 마찬가지로 `memberId`라는 값을 받아서 해당 아이디를 갖는 멤버의 별명을 보여주는 컴포넌트 입니다.


```jsx
import PropTypes from 'prop-types';
import React, { PureComponent } from 'react';

class MemberNickname extends PureComponent {
  static propTypes = {
    memberId: PropTypes.string.isRequired,
  };
  
}

export default MemberNickname;
```

`MemberName` 컴포넌트와 마찬가지로 `memberId`를 꼭 필요로 하기 때문에 `PropTypes.string.isRequired`로 정의합니다.


```jsx
import PropTypes from 'prop-types';
import React, { PureComponent } from 'react';
import membersStore from './membersStore';

class MemberNickname extends PureComponent {
  static propTypes = {
    memberId: PropTypes.string.isRequired,
  };

  getMember = () => {
    return membersStore.getById(this.props.memberId);
  };
  
}

export default MemberNickname;
```

그리고 `memberId` 값으로 멤버 정보를 가져옵니다.


```jsx
import PropTypes from 'prop-types';
import React, { PureComponent } from 'react';
import membersStore from './membersStore';

class MemberNickname extends PureComponent {
  static propTypes = {
    memberId: PropTypes.string.isRequired,
  };

  getMember = () => {
    return membersStore.getById(this.props.memberId);
  };
  
  render() {
    return <div>{this.getMember().nickname}</div>;
  }
}

export default MemberNickname;
```

이제 `getMember` 메소드로 멤버 정보를 가져와 nickname을 렌더링 하도록 합니다.

</CodeWave>

위 두 컴포넌트에서 멤버의 이름과 닉네임을 가져오기 위해 membersStore에서 memberId를 이용해 멤버 정보를 가져오도록 했습니다.
여기서 중복 로직이 생겼습니다. `memberId`를 이용해서 멤버 정보를 가져오는 부분이 똑같이 생겼는데요.
두 컴포넌트에서 각자가 구현한 getMember 메소드가 있기 때문에 `membersStore`에서 `getById`라는 메소드 이름을 수정하게 되면 두 코드 모두에서 수정해줘야 하는 상황이 생깁니다.
이런 중복을 없애기 위해서 두 가지 방법이 있습니다. 첫 째, `HOC`를 이용한 방법. 둘 째, `render prop`을 이용한 방법.


<CodeWave>

```jsx
```

## HOC(Higher Order Component)

먼저 HOC를 이용해서 중복 로직을 제거하는 방법에 대해서 살펴보도록 하겠습니다. <a href="https://reactjs.org/docs/higher-order-components.html" rel="noopener" target="_blank">HOC(Higher Order Component)</a>에 대한 자세한 정보는 

</CodeWave>


첫 번째로 <a href="https://reactjs.org/docs/higher-order-components.html" rel="noopener" target="_blank">HOC(Higher Order Component)</a>를 이용하는 방법이 있겠다. 
HOC를 간단하게 설명하면 컴포넌트를 감싸서 뭔가 작업을한 후 props를 통해 작업한 결과를 넘겨주는 컴포넌트라고 생각하면 된다.

HOC를 이용해서 어떻게 중복을 제거하는지 아래를 살펴보자.

아래를 보면 중복코드를 하나의 HOC 컴포넌트로 뽑아냈다.


```jsx file=./03.jsx
```

memberLoader HOC가 하는 일은 이전에 MemberName, MemberNickname 컴포넌트가 받았던 memberId를 prop으로 받아서 membersStore에 있는 멤버 정보를 가져다가 member라는 prop을 새로 만들어 전달하는 역할을 한다.

아래 memberLoader HOC를 이용한 MemberName과 MemberNickname이 있다.

```jsx
import PropTypes from 'prop-types';
import React, {PureComponent} from 'react';
import memberLoader from './memberLoader';

class MemberName extends PureComponent {
    static propTypes = {
        member: PropTypes.object.isRequired
    };

    render() {
        return <span>{this.props.member.name}</span>;
    }
}

export default memberLoader(MemberName);
```

```jsx
import PropTypes from 'prop-types';
import React, {PureComponent} from 'react';
import memberLoader from './memberLoader';

class MemberNickname extends PureComponent {
    static propTypes = {
        member: PropTypes.object.isRequired
    };

    render() {
        return <span>{this.props.member.nickname}</span>;
    }
}

export default memberLoader(MemberNickname);
```

MemberName, MemberNickname 컴포넌트를 export default 할때 memberLoader로 한 번 감싼 부분을 보자.
이렇게 사용하면 memberId를 memberLoader에서 처리해서 새로운 member prop을 받게 된다.

### Render Prop

두 번째로 Render Prop을 이용한 방법을 살펴보자. Render Prop을 간단하게 설명하면 렌더링 할 JSX를 function형태로 prop으로 넘기는 것을 맒한다.

```jsx
import PropTypes from 'prop-types';
import React, {PureComponent} from 'react';
import membersStore from './membersStore';

class MemberLoader extends PureComponent {
    static propTypes = {
        memberId: PropTypes.string.isRequired,
        render: PropTypes.func.isRequired
    };
    
    getMember = () => {
        membersStore.getById(this.props.memberId);
    };
    
    render() {
        return this.props.render(this.getMember());
    }
}

export default MemberLoader;
```

위 코드는 Render Prop을 이용해서 중복코드를 제거한 컴포넌트이다. 
HOC와 다른 점이 몇가지 있다.
1. function을 반환하는 게 아니라 class를 반환.
2. WrappedComponent를 받는게 아니라 render라는 prop이 필요.(render는 function이다.)

prop으로 받은 render 함수에 멤버정보를 파라미터로 넘기며 실행한다.

그럼 위 MemberLoader 컴포넌트를 어떻게 활용하는지 살펴보자.

```jsx
import PropTypes from 'prop-types';
import React, {PureComponent} from 'react';
import MemberLoader from './MemberLoader';

class MemberName extends PureComponent {
    static propTypes = {
        memberId: PropTypes.object.isRequired
    };

    render() {
        return (
            <MemberLoader 
                memberId={this.props.memberId}
                render={(member) => {
                    return <span>{member.name}</span>
                }}
            />
        );
    }
}

export default MemberName;
```

```jsx
import PropTypes from 'prop-types';
import React, {PureComponent} from 'react';
import MemberLoader from './MemberLoader';

class MemberNickname extends PureComponent {
    static propTypes = {
        memberId: PropTypes.object.isRequired
    };

    render() {
        return (
            <MemberLoader 
                memberId={this.props.memberId}
                render={(member) => {
                    return <span>{member.nickname}</span>
                }}
            />
        );
    }
}
export default MemberNickname;
```

MemberName과 MemberNickname에서 MemberLoader 컴포넌트를 사용하게 된다. 
prop으로 memberId를 넘겨서 MemberLoader 컴포넌트가 멤버 정보를 가져오도록 처리한다.
prop으로 render에 member를 받아서 각 각 이름과 닉네임을 반환해주는 함수를 넘겨준다. 이 render로 넘겨준 함수를 MemberLoader 컴포넌트가 멤버 정보화 함께 실행해준다.

개이적으로 처음에는 HOC 형태를 많이 썼으나 Render Prop을 알게 된 후로는 중복코드 제거에 Render Prop을 사용하고 있다.
Render Prop을 더 선호하는 이유에 몇가지가 있다.
1. HOC를 사용할 때 member prop이 어디서 오는지 알 수가 없다.

**MemberName을 사용할 때**
```jsx
<MemberName memberId={someMemberId}/>
```

위와 같은 형태로 **memberId만** prop으로 넘겨서 사용하게 된다.

**HOC**
 ```jsx
import PropTypes from 'prop-types';
import React, {PureComponent} from 'react';
import memberLoader from './memberLoader';

class MemberName extends PureComponent {
    static propTypes = {
        member: PropTypes.object.isRequired
    };

    render() {
        return <span>{this.props.member.name}</span>;
    }
}

export default memberLoader(MemberName);
```

실제 MemberName 컴포넌트를 사용 할 때는 memberId만 prop으로 넘겨줬는데 실제 사용하는 부분에서는 **member도 prop에 노출**되니 이 member가 어디서 온 prop인지 한 눈에 파악하기가 힘든점이 있다. 
반면에 Render Propr을 살펴보자.

**Render Prop**

```jsx
import PropTypes from 'prop-types';
import React, {PureComponent} from 'react';
import MemberLoader from './MemberLoader';

class MemberName extends PureComponent {
    static propTypes = {
        memberId: PropTypes.object.isRequired
    };

    render() {
        return (
            <MemberLoader 
                memberId={this.props.memberId}
                render={(member) => {
                    return <span>{member.name}</span>
                }}
            />
        );
    }
}

export default MemberName;
```

MemberName를 사용할 때 넘겨준 memberId를 그대로 MemberLoader로 넘겨주면서 함께 넘겨준 render 함수 내부에 member를 받아서 멤버의 이름 정보를 보여준다. 
개인적인 생각일 수있지만 HOC에 비해 훨씬 코드가 읽기 쉽다고 생각한다.

##### 2. HOC가 Render Prop방법에 비해 더 복잡해 보인다.

**HOC**
```jsx
import PropTypes from 'prop-types';
import React, {PureComponent} from 'react';
import membersStore from './membersStore';

export default function memberLoader(WrappedComponent) {
    class MemberLoader extends PureComponent {
        static propTypes = {
            memberId: PropTypes.string.isRequired
        };

        getMember = () =>
            membersStore.getById(this.props.memberId);
        
        render() {
            return <WrappedComponent {...this.props} member={this.getMember()}/>;
        }
    }
    return MemberLoader;
}
```

**Render Prop** 
```jsx
import PropTypes from 'prop-types';
import React, {PureComponent} from 'react';
import membersStore from './membersStore';

class MemberLoader extends PureComponent {
    static propTypes = {
        memberId: PropTypes.string.isRequired,
        render: PropTypes.func.isRequired
    };
    
    getMember = () => {
        membersStore.getById(this.props.memberId);
    };
    
    render() {
        return this.props.render(this.getMember());
    }
}

export default MemberLoader;
```

Render Prop이 React에서 사용하는 일반 컴포넌트 형태인것에 반해 HOC는 컴포넌트를 function으로 한번 더 감싼 행태이다. 
거기에 한 번 더 감싸줄 컴포넌트를 function의 파라미터로 받아 WrappedComponent를 render 메소드에서 렌더링 해준다.

이런 이유들로 Render Prop을 더 선호하는데 이건 개인취향이니 각자 알아서 골라쓰면 될것 같다.

**Render Prop에서 꼭 render라는 prop을 써야 할까??**

당연히 아니다 자신이 마음에 드는 prop 이름을 정의해서 사용하면 그만이다. 게다가 prop으로 넘기기도 귀찮다면 children을 이용해도 좋다.

```jsx
import PropTypes from 'prop-types';
import React, {PureComponent} from 'react';
import membersStore from './membersStore';

class MemberLoader extends PureComponent {
    static propTypes = {
        memberId: PropTypes.string.isRequired,
        children: PropTypes.func.isRequired
    };
    
    getMember = () => {
        membersStore.getById(this.props.memberId);
    };
    
    render() {
        return this.props.children(this.getMember());
    }
}

export default MemberLoader;
```


```jsx
import PropTypes from 'prop-types';
import React, {PureComponent} from 'react';

class MemberNickname extends PureComponent {
    static propTypes = {
        memberId: PropTypes.object.isRequired
    };

    render() {
        return (
            <MemberLoader memberId={this.props.memberId}>
                {(member) => {
                    return <span>{member.nickname}</span>
                }}
            </MemberLoader>
        );
    }
}

export default MemberNickname;
```

위 코드처럼 render prop 대신 MemberLoader의 children에 function을 넣어서 사용해도 결과는 같다.

[code-smell]: https://github.com/mojombo/jekyll
